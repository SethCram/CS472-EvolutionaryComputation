from functools import update_wrapper
import unittest

from RealValue_IslandModels_Lib import *

class TestCreationMethods(unittest.TestCase):

    def test_IndividualCreation(self):
        """
        Tests individual creation function once for every function.
        Ensures each generated trait is a 64 bit numpy float, 
        within the function's domain,
        and has the correct number of traits.
        """
        
        #for function in GA_Functions:
        
        #walk thru funct bounds dict
        for functionEnum, functionBounds in functionBoundsDict.items():
            
            #store bounds
            lower_bound, upper_bound = functionBounds
            #create rando individual
            
            testIndividual = CreateRandomIndividual(
                num_of_traits=INDIVIDUALS_NUMBER_OF_TRAITS, 
                lower_bound_inclusive=lower_bound,
                upper_bound_inclusive=upper_bound
            )
            
            #trait number check
            self.assertTrue(
                len(testIndividual) == INDIVIDUALS_NUMBER_OF_TRAITS,
                "A test trait for {} doesn't have {} traits.".format(functionEnum, INDIVIDUALS_NUMBER_OF_TRAITS) 
            )
            
            #walk thru individual's traits
            for testTrait in testIndividual:
                #bounds check
                self.assertTrue( 
                    testTrait >= lower_bound and testTrait <= upper_bound, 
                    "A test trait for {} is out of bounds.".format(functionEnum) 
                )
                #type check
                testTraitType = type(testTrait)
                self.assertTrue(
                    testTraitType == numpy.float64,
                    "A test trait for {} isn't a float. It's a {}.".format(functionEnum, testTraitType) 
                )

    def test_PopulationCreation(self):
        """
        Creates a population for each funct 
        and verifies it's the right size.
        """
        #walk thru funct bounds dict
        for functionEnum, functionBounds in functionBoundsDict.items():
            #create new population
            population = CreatePopulation(
                functionBounds=functionBounds, 
                population_size=POPULATION_SIZE, 
                individuals_num_of_traits=INDIVIDUALS_NUMBER_OF_TRAITS
            )
            
            newPopSize = len(population)
            
            #pop size check
            self.assertTrue(
                newPopSize == POPULATION_SIZE,
                "Size of population was changed to {} for {}.".format(newPopSize, functionEnum)
            )

class TestFitnessRelated(unittest.TestCase):
    def test_EvalFitness(self):
        """
        Test to make sure an individual with the target input as traits 
        results in a fitness of zero for every function.
        """
        
        #walk thru funct bounds dict
        for functionEnum, functionTargetInput in functionInputTargetDict.items():
            
            testIndividual = numpy.full(INDIVIDUALS_NUMBER_OF_TRAITS, functionTargetInput, dtype=float)
            
            testIndividualFitness = EvalFitness(functionEnum, testIndividual)
            
            errorMsg = "When evaluated with an individual of all {}, {} resulted in a fitness of {}, not zero.".format(functionTargetInput, functionEnum, testIndividualFitness)
            
            self.assertEqual( 
                testIndividualFitness,
                0,
                errorMsg
            )
            
class TestSelectionRelatedMethods(unittest.TestCase):
    def test_SetupHalfNormIntDistr(self):
        """
        Tests the half normal integer distribution parent indices are drawn from.
        Verifies that a lower index number occures more often than a higher index number.
        """
        
        testDataCount = 1000000
        
        xIndexRange, prob = SetupHalfNormIntDistr(POPULATION_SIZE)
        
        #take rando nums using the calc'd prob and index range
        randoNums = numpy.random.choice(xIndexRange, size = testDataCount, p = prob)

        #get count of each unique num gen'd
        unique, counts = numpy.unique(randoNums, return_counts=True)
        
        #pair count of each index in a dict
        indexCountDict = dict(zip(unique, counts))
        
        compIndex1 = 0
        compIndex2 = int(POPULATION_SIZE/3)
        
        #ensure index 0 occured more often than the comp2 index
        self.assertGreater(
            indexCountDict[compIndex1],
            indexCountDict[compIndex2],
            "A lower index in the distribution should usually occure more often."
        )

    def test_BreedSelection(self):
        """
        Tests that all parents generated by the selection function 
        come from the population, and if told to display the distribution graph
        the selection function displays a plot.
        """
        
        populationFitness = [None] * POPULATION_SIZE
        
        for functionEnum, functionBounds in functionBoundsDict.items():
        
            #create new population
            population = CreatePopulation(
                functionBounds=functionBounds, 
                population_size=POPULATION_SIZE, 
                individuals_num_of_traits=INDIVIDUALS_NUMBER_OF_TRAITS
            )

            #walk thru each individual in pop
            for i in range(0, POPULATION_SIZE):
                individual = population[i]
                individualFitness = EvalFitness(functionEnum, individual)
                
                #store individual w/ their fitness data
                populationFitness[i] = IndividualFitness( individual, individualFitness )
            
            #get parents from pop-fitness obj    
            parents = BreedSelection(populationFitness)
            
            #walk thru parents
            for parent in parents:
                #make sure each parent is actually in the pop
                self.assertTrue(
                    any((numpy.array_equal(parent, individual)) for individual in population),
                    "One of the selected parents isn't in the population."
                )
            
            #cache figures gen'd by matplotlib
            prevPlottedFigures = plt.get_fignums()
            
            #show distr figure for parents
            BreedSelection(populationFitness, displayDistributionGraph=True)

            #cache figures gen'd by matplotlib
            afterPlottedFigures = plt.get_fignums()
            
            #close any open plots
            plt.close()
            
            #make sure a plot was actually displayed
            self.assertGreater( afterPlottedFigures, prevPlottedFigures,
                "Plot never generated to show Breed Selection parent index distribution."    
            )
            
if __name__ == '__main__':
    unittest.main()