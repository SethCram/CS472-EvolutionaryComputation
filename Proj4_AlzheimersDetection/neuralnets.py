# -*- coding: utf-8 -*-
"""neuralnets

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XwSkeyX-cWaLt6CncrNRnjbqQxvpmvnf
"""

from IPython.display import Image

Image(url='https://media1.giphy.com/media/3o6fJgEOrF1lky8WFa/giphy.gif?cid=ecf05e477rvtlofet4rij55gb1xdsf2fbsbqs3q4waodde8b&rid=giphy.gif')

import numpy as np
import copy
import math

def sigmoid(Z):
    return 1/(1+np.exp(-Z))

L1InSize = 2
L1OutSize = 2
L2InSize = 2
L2OutSize = 2
L3InSize = 2
L3OutSize = 1

input = np.array([[0,0],[1,0],[0,1],[1,1]])
print(input)

W1 = np.array([np.random.random() for i in range(L1InSize * L1OutSize)])
W1 = W1.reshape(L1InSize,L1OutSize)
print(W1)

input = np.transpose(input)

L2In = np.dot(W1, input)

print(L2In)

L2In = sigmoid(L2In)

print(L2In)

W2 = np.array([np.random.random() for i in range(L2InSize * L2OutSize)])
W2 = W2.reshape(L2InSize,L2OutSize)
print(W2)

print(L2In)

L3In = np.dot(W2, L2In)

print(L3In)

L3In = sigmoid(L3In)

W3 = np.array([np.random.random() for i in range(L3InSize * L3OutSize)])
W3 = W3.reshape(L3OutSize, L3InSize)
print(W3)



out = np.dot(W3, L3In)

print(out)

popSize = 100
CrossoverRate = .8
MutationSTD = .2
nextGen = []
geneSize = 6

pop = [[round(np.random.random(), 2) for i in range(geneSize)] for i in range(popSize)]

fitness = [5 for i in range(popSize)]

p1, p2 = None, None
c1, c2 = None, None

def selection():
  global p1, p2
  cont = np.random.choice(popSize, geneSize)
  p = cont[0]
  for i in range(1,3):
    if fitness[i] < fitness[p]:
      p = i
  p1 = pop[p]
  p = cont[3]
  for i in range(4,6):
    if fitness[i] < fitness[p]:
      p = i
  p2 = pop[p]

def crossover():
  global c1, c2, p1, p2
  c1, c2 = [], []

  for i in range(geneSize):
    if np.random.random() < .5:
      c1.append(p1[i])
      c2.append(p2[i])
    else:
      c1.append(p2[i])
      c2.append(p1[i])

def mutate():
  global c1, c2
  c1[np.random.choice(geneSize)] += round(np.random.normal(0, MutationSTD),2)
  c2[np.random.choice(geneSize)] += round(np.random.normal(0, MutationSTD),2)
  c1[np.random.choice(geneSize)] += round(np.random.normal(0, MutationSTD),2)
  c2[np.random.choice(geneSize)] += round(np.random.normal(0, MutationSTD),2)
  for g1 in c1:
    g1 = round(g1,2)
  for g1 in c2:
    g1 = round(g1,2)

def GetActualOutput(ind):
  L1InSize = 2
  L1OutSize = 2
  L2InSize = 2
  L2OutSize = 1
  
  #input layer, here values may need to be normalized
  input = np.array([[0,0],[1,0],[0,1],[1,1]])

  #Weights going to first layer
  W1 = np.array([ind[i] for i in range(L1InSize * L1OutSize)])
  W1 = W1.reshape(L1InSize,L1OutSize)
 
  input = np.transpose(input)
  L1In = np.dot(W1, input)
  L1In = sigmoid(L1In)
  W2 = np.array([ind[i + (L1InSize * L1OutSize)] for i in range(L2InSize * L2OutSize)])
  W2 = W2.reshape(L2OutSize, L2InSize)

  ActualOut = np.dot(W2, L1In)
  
  for i,n in enumerate(ActualOut[0]):
    ActualOut[0][i] = round(n,3)
  return ActualOut

def calcFitness():
  global fitness, pop
  fitness = []
  for i in range(popSize):
    ExpectedOut = np.array([0,1,1,0])
    ActualOut = GetActualOutput(pop[i])[0]
    #print("Expected: ", ExpectedOut)
    #print("Actual:   ", ActualOut)
    dif = ExpectedOut - ActualOut
    
    #print("Dif:      ", dif)
    error = 0
    for val in dif:
      error += abs(val)
    
    serror = 0
    for val in dif:
      serror += val ** 2
    rmse = math.sqrt( serror / geneSize  )
    fitness.append(round(rmse, 3))

  #print(f"Error: {error}")
  #print(f"RMSE : {rmse}")

def runGen():
  global pop, nextGen,c1,c2,p1,p2
  nextGen = []
  for i in range(popSize//2):
    selection()
    crossover()
    mutate()
    nextGen.append(copy.deepcopy(c1))
    nextGen.append(copy.deepcopy(c2))
  pop = copy.deepcopy(nextGen)
  calcFitness()

runGen()

pop = [[round(np.random.random(), 2) for i in range(geneSize)] for i in range(popSize)]
calcFitness()
print("Best: ", np.min(fitness))
print("Average: ", np.average(fitness))

for i in range(100):
  runGen()
  print(f"{i}-------------")
  print("Best: ", np.min(fitness))
  #print(fitness)
  #print(pop[fitness.index(np.min(fitness))])
  print("Average: ", np.average(fitness))

b= GetActualOutput(pop[fitness.index(np.min(fitness))])[0]

pop[fitness.index(np.min(fitness))]

for i, val in enumerate(b):
  b[i] = round(val, 0)

print(b)